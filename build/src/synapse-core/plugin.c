/* plugin.c generated by valac 0.50.1, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 *
 */

#include <glib-object.h>
#include <glib.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>

#define SYNAPSE_TYPE_ACTIVATABLE (synapse_activatable_get_type ())
#define SYNAPSE_ACTIVATABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_ACTIVATABLE, SynapseActivatable))
#define SYNAPSE_IS_ACTIVATABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_ACTIVATABLE))
#define SYNAPSE_ACTIVATABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_ACTIVATABLE, SynapseActivatableIface))

typedef struct _SynapseActivatable SynapseActivatable;
typedef struct _SynapseActivatableIface SynapseActivatableIface;

#define SYNAPSE_TYPE_CONFIGURABLE (synapse_configurable_get_type ())
#define SYNAPSE_CONFIGURABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_CONFIGURABLE, SynapseConfigurable))
#define SYNAPSE_IS_CONFIGURABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_CONFIGURABLE))
#define SYNAPSE_CONFIGURABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_CONFIGURABLE, SynapseConfigurableIface))

typedef struct _SynapseConfigurable SynapseConfigurable;
typedef struct _SynapseConfigurableIface SynapseConfigurableIface;

#define SYNAPSE_TYPE_ITEM_PROVIDER (synapse_item_provider_get_type ())
#define SYNAPSE_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_ITEM_PROVIDER, SynapseItemProvider))
#define SYNAPSE_IS_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_ITEM_PROVIDER))
#define SYNAPSE_ITEM_PROVIDER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_ITEM_PROVIDER, SynapseItemProviderIface))

typedef struct _SynapseItemProvider SynapseItemProvider;
typedef struct _SynapseItemProviderIface SynapseItemProviderIface;

#define SYNAPSE_TYPE_QUERY (synapse_query_get_type ())
typedef struct _SynapseQuery SynapseQuery;
typedef enum  {
	SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE = 1 << 0,
	SYNAPSE_QUERY_FLAGS_UNCATEGORIZED = 1 << 1,
	SYNAPSE_QUERY_FLAGS_APPLICATIONS = 1 << 2,
	SYNAPSE_QUERY_FLAGS_ACTIONS = 1 << 3,
	SYNAPSE_QUERY_FLAGS_AUDIO = 1 << 4,
	SYNAPSE_QUERY_FLAGS_VIDEO = 1 << 5,
	SYNAPSE_QUERY_FLAGS_DOCUMENTS = 1 << 6,
	SYNAPSE_QUERY_FLAGS_IMAGES = 1 << 7,
	SYNAPSE_QUERY_FLAGS_FILES = ((SYNAPSE_QUERY_FLAGS_AUDIO | SYNAPSE_QUERY_FLAGS_VIDEO) | SYNAPSE_QUERY_FLAGS_DOCUMENTS) | SYNAPSE_QUERY_FLAGS_IMAGES,
	SYNAPSE_QUERY_FLAGS_PLACES = 1 << 8,
	SYNAPSE_QUERY_FLAGS_INTERNET = 1 << 9,
	SYNAPSE_QUERY_FLAGS_TEXT = 1 << 10,
	SYNAPSE_QUERY_FLAGS_CONTACTS = 1 << 11,
	SYNAPSE_QUERY_FLAGS_ALL = 0xFFFFFFFFLL,
	SYNAPSE_QUERY_FLAGS_LOCAL_CONTENT = SYNAPSE_QUERY_FLAGS_ALL ^ SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE
} SynapseQueryFlags;

#define SYNAPSE_TYPE_QUERY_FLAGS (synapse_query_flags_get_type ())

#define SYNAPSE_TYPE_RESULT_SET (synapse_result_set_get_type ())
#define SYNAPSE_RESULT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_RESULT_SET, SynapseResultSet))
#define SYNAPSE_RESULT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_TYPE_RESULT_SET, SynapseResultSetClass))
#define SYNAPSE_IS_RESULT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_RESULT_SET))
#define SYNAPSE_IS_RESULT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_TYPE_RESULT_SET))
#define SYNAPSE_RESULT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_TYPE_RESULT_SET, SynapseResultSetClass))

typedef struct _SynapseResultSet SynapseResultSet;
typedef struct _SynapseResultSetClass SynapseResultSetClass;

#define SYNAPSE_TYPE_ACTION_PROVIDER (synapse_action_provider_get_type ())
#define SYNAPSE_ACTION_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_ACTION_PROVIDER, SynapseActionProvider))
#define SYNAPSE_IS_ACTION_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_ACTION_PROVIDER))
#define SYNAPSE_ACTION_PROVIDER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_ACTION_PROVIDER, SynapseActionProviderIface))

typedef struct _SynapseActionProvider SynapseActionProvider;
typedef struct _SynapseActionProviderIface SynapseActionProviderIface;

#define SYNAPSE_TYPE_MATCH (synapse_match_get_type ())
#define SYNAPSE_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_MATCH, SynapseMatch))
#define SYNAPSE_IS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_MATCH))
#define SYNAPSE_MATCH_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_MATCH, SynapseMatchIface))

typedef struct _SynapseMatch SynapseMatch;
typedef struct _SynapseMatchIface SynapseMatchIface;
typedef enum  {
	SYNAPSE_MATCH_TYPE_UNKNOWN = 0,
	SYNAPSE_MATCH_TYPE_TEXT,
	SYNAPSE_MATCH_TYPE_APPLICATION,
	SYNAPSE_MATCH_TYPE_GENERIC_URI,
	SYNAPSE_MATCH_TYPE_ACTION,
	SYNAPSE_MATCH_TYPE_SEARCH,
	SYNAPSE_MATCH_TYPE_CONTACT
} SynapseMatchType;

#define SYNAPSE_TYPE_MATCH_TYPE (synapse_match_type_get_type ())

struct _SynapseActivatableIface {
	GTypeInterface parent_iface;
	void (*activate) (SynapseActivatable* self);
	void (*deactivate) (SynapseActivatable* self);
	gboolean (*get_enabled) (SynapseActivatable* self);
	void (*set_enabled) (SynapseActivatable* self, gboolean value);
};

struct _SynapseConfigurableIface {
	GTypeInterface parent_iface;
	GtkWidget* (*create_config_widget) (SynapseConfigurable* self);
};

struct _SynapseQuery {
	gchar* query_string;
	gchar* query_string_folded;
	GCancellable* cancellable;
	SynapseQueryFlags query_type;
	guint max_results;
	guint query_id;
};

typedef enum  {
	SYNAPSE_SEARCH_ERROR_SEARCH_CANCELLED,
	SYNAPSE_SEARCH_ERROR_UNKNOWN_ERROR
} SynapseSearchError;
#define SYNAPSE_SEARCH_ERROR synapse_search_error_quark ()
struct _SynapseItemProviderIface {
	GTypeInterface parent_iface;
	void (*search) (SynapseItemProvider* self, SynapseQuery* query, GAsyncReadyCallback _callback_, gpointer _user_data_);
	SynapseResultSet* (*search_finish) (SynapseItemProvider* self, GAsyncResult* _res_, GError** error);
	gboolean (*handles_query) (SynapseItemProvider* self, SynapseQuery* query);
	gboolean (*handles_empty_query) (SynapseItemProvider* self);
};

struct _SynapseMatchIface {
	GTypeInterface parent_iface;
	void (*execute) (SynapseMatch* self, SynapseMatch* match);
	void (*execute_with_target) (SynapseMatch* self, SynapseMatch* source, SynapseMatch* target);
	gboolean (*needs_target) (SynapseMatch* self);
	SynapseQueryFlags (*target_flags) (SynapseMatch* self);
	const gchar* (*get_title) (SynapseMatch* self);
	void (*set_title) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_description) (SynapseMatch* self);
	void (*set_description) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_icon_name) (SynapseMatch* self);
	void (*set_icon_name) (SynapseMatch* self, const gchar* value);
	gboolean (*get_has_thumbnail) (SynapseMatch* self);
	void (*set_has_thumbnail) (SynapseMatch* self, gboolean value);
	const gchar* (*get_thumbnail_path) (SynapseMatch* self);
	void (*set_thumbnail_path) (SynapseMatch* self, const gchar* value);
	SynapseMatchType (*get_match_type) (SynapseMatch* self);
	void (*set_match_type) (SynapseMatch* self, SynapseMatchType value);
};

struct _SynapseActionProviderIface {
	GTypeInterface parent_iface;
	SynapseResultSet* (*find_for_match) (SynapseActionProvider* self, SynapseQuery* query, SynapseMatch* match);
	gboolean (*handles_unknown) (SynapseActionProvider* self);
};

GType synapse_activatable_get_type (void) G_GNUC_CONST;
void synapse_activatable_activate (SynapseActivatable* self);
void synapse_activatable_deactivate (SynapseActivatable* self);
gboolean synapse_activatable_get_enabled (SynapseActivatable* self);
void synapse_activatable_set_enabled (SynapseActivatable* self,
                                      gboolean value);
static GType synapse_activatable_get_type_once (void);
GType synapse_configurable_get_type (void) G_GNUC_CONST;
GtkWidget* synapse_configurable_create_config_widget (SynapseConfigurable* self);
static GType synapse_configurable_get_type_once (void);
GType synapse_query_get_type (void) G_GNUC_CONST;
GType synapse_query_flags_get_type (void) G_GNUC_CONST;
SynapseQuery* synapse_query_dup (const SynapseQuery* self);
void synapse_query_free (SynapseQuery* self);
void synapse_query_copy (const SynapseQuery* self,
                         SynapseQuery* dest);
void synapse_query_destroy (SynapseQuery* self);
GType synapse_result_set_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SynapseResultSet, g_object_unref)
GQuark synapse_search_error_quark (void);
GType synapse_item_provider_get_type (void) G_GNUC_CONST;
void synapse_item_provider_search (SynapseItemProvider* self,
                                   SynapseQuery* query,
                                   GAsyncReadyCallback _callback_,
                                   gpointer _user_data_);
SynapseResultSet* synapse_item_provider_search_finish (SynapseItemProvider* self,
                                                       GAsyncResult* _res_,
                                                       GError** error);
gboolean synapse_item_provider_handles_query (SynapseItemProvider* self,
                                              SynapseQuery* query);
static gboolean synapse_item_provider_real_handles_query (SynapseItemProvider* self,
                                                   SynapseQuery* query);
gboolean synapse_item_provider_handles_empty_query (SynapseItemProvider* self);
static gboolean synapse_item_provider_real_handles_empty_query (SynapseItemProvider* self);
static GType synapse_item_provider_get_type_once (void);
GType synapse_match_type_get_type (void) G_GNUC_CONST;
GType synapse_match_get_type (void) G_GNUC_CONST;
GType synapse_action_provider_get_type (void) G_GNUC_CONST;
SynapseResultSet* synapse_action_provider_find_for_match (SynapseActionProvider* self,
                                                          SynapseQuery* query,
                                                          SynapseMatch* match);
gboolean synapse_action_provider_handles_unknown (SynapseActionProvider* self);
static gboolean synapse_action_provider_real_handles_unknown (SynapseActionProvider* self);
static GType synapse_action_provider_get_type_once (void);

void
synapse_activatable_activate (SynapseActivatable* self)
{
	SynapseActivatableIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = SYNAPSE_ACTIVATABLE_GET_INTERFACE (self);
	if (_iface_->activate) {
		_iface_->activate (self);
	}
}

void
synapse_activatable_deactivate (SynapseActivatable* self)
{
	SynapseActivatableIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = SYNAPSE_ACTIVATABLE_GET_INTERFACE (self);
	if (_iface_->deactivate) {
		_iface_->deactivate (self);
	}
}

gboolean
synapse_activatable_get_enabled (SynapseActivatable* self)
{
	SynapseActivatableIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = SYNAPSE_ACTIVATABLE_GET_INTERFACE (self);
	if (_iface_->get_enabled) {
		return _iface_->get_enabled (self);
	}
	return FALSE;
}

void
synapse_activatable_set_enabled (SynapseActivatable* self,
                                 gboolean value)
{
	SynapseActivatableIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = SYNAPSE_ACTIVATABLE_GET_INTERFACE (self);
	if (_iface_->set_enabled) {
		_iface_->set_enabled (self, value);
	}
}

static void
synapse_activatable_default_init (SynapseActivatableIface * iface,
                                  gpointer iface_data)
{
	g_object_interface_install_property (iface, g_param_spec_boolean ("enabled", "enabled", "enabled", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static GType
synapse_activatable_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SynapseActivatableIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_activatable_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType synapse_activatable_type_id;
	synapse_activatable_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseActivatable", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (synapse_activatable_type_id, G_TYPE_OBJECT);
	return synapse_activatable_type_id;
}

GType
synapse_activatable_get_type (void)
{
	static volatile gsize synapse_activatable_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_activatable_type_id__volatile)) {
		GType synapse_activatable_type_id;
		synapse_activatable_type_id = synapse_activatable_get_type_once ();
		g_once_init_leave (&synapse_activatable_type_id__volatile, synapse_activatable_type_id);
	}
	return synapse_activatable_type_id__volatile;
}

GtkWidget*
synapse_configurable_create_config_widget (SynapseConfigurable* self)
{
	SynapseConfigurableIface* _iface_;
	g_return_val_if_fail (self != NULL, NULL);
	_iface_ = SYNAPSE_CONFIGURABLE_GET_INTERFACE (self);
	if (_iface_->create_config_widget) {
		return _iface_->create_config_widget (self);
	}
	return NULL;
}

static void
synapse_configurable_default_init (SynapseConfigurableIface * iface,
                                   gpointer iface_data)
{
}

static GType
synapse_configurable_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SynapseConfigurableIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_configurable_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType synapse_configurable_type_id;
	synapse_configurable_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseConfigurable", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (synapse_configurable_type_id, G_TYPE_OBJECT);
	return synapse_configurable_type_id;
}

GType
synapse_configurable_get_type (void)
{
	static volatile gsize synapse_configurable_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_configurable_type_id__volatile)) {
		GType synapse_configurable_type_id;
		synapse_configurable_type_id = synapse_configurable_get_type_once ();
		g_once_init_leave (&synapse_configurable_type_id__volatile, synapse_configurable_type_id);
	}
	return synapse_configurable_type_id__volatile;
}

void
synapse_item_provider_search (SynapseItemProvider* self,
                              SynapseQuery* query,
                              GAsyncReadyCallback _callback_,
                              gpointer _user_data_)
{
	SynapseItemProviderIface* _iface_;
	_iface_ = SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self);
	if (_iface_->search) {
		_iface_->search (self, query, _callback_, _user_data_);
	}
}

SynapseResultSet*
synapse_item_provider_search_finish (SynapseItemProvider* self,
                                     GAsyncResult* _res_,
                                     GError** error)
{
	SynapseItemProviderIface* _iface_;
	_iface_ = SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self);
	if (_iface_->search_finish) {
		return _iface_->search_finish (self, _res_, error);
	}
	return NULL;
}

static gboolean
synapse_item_provider_real_handles_query (SynapseItemProvider* self,
                                          SynapseQuery* query)
{
	gboolean result = FALSE;
	g_return_val_if_fail (query != NULL, FALSE);
	result = TRUE;
	return result;
}

gboolean
synapse_item_provider_handles_query (SynapseItemProvider* self,
                                     SynapseQuery* query)
{
	SynapseItemProviderIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self);
	if (_iface_->handles_query) {
		return _iface_->handles_query (self, query);
	}
	return FALSE;
}

static gboolean
synapse_item_provider_real_handles_empty_query (SynapseItemProvider* self)
{
	gboolean result = FALSE;
	result = FALSE;
	return result;
}

gboolean
synapse_item_provider_handles_empty_query (SynapseItemProvider* self)
{
	SynapseItemProviderIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self);
	if (_iface_->handles_empty_query) {
		return _iface_->handles_empty_query (self);
	}
	return FALSE;
}

static void
synapse_item_provider_default_init (SynapseItemProviderIface * iface,
                                    gpointer iface_data)
{
	iface->handles_query = synapse_item_provider_real_handles_query;
	iface->handles_empty_query = synapse_item_provider_real_handles_empty_query;
}

static GType
synapse_item_provider_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SynapseItemProviderIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_item_provider_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType synapse_item_provider_type_id;
	synapse_item_provider_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseItemProvider", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (synapse_item_provider_type_id, SYNAPSE_TYPE_ACTIVATABLE);
	return synapse_item_provider_type_id;
}

GType
synapse_item_provider_get_type (void)
{
	static volatile gsize synapse_item_provider_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_item_provider_type_id__volatile)) {
		GType synapse_item_provider_type_id;
		synapse_item_provider_type_id = synapse_item_provider_get_type_once ();
		g_once_init_leave (&synapse_item_provider_type_id__volatile, synapse_item_provider_type_id);
	}
	return synapse_item_provider_type_id__volatile;
}

SynapseResultSet*
synapse_action_provider_find_for_match (SynapseActionProvider* self,
                                        SynapseQuery* query,
                                        SynapseMatch* match)
{
	SynapseActionProviderIface* _iface_;
	g_return_val_if_fail (self != NULL, NULL);
	_iface_ = SYNAPSE_ACTION_PROVIDER_GET_INTERFACE (self);
	if (_iface_->find_for_match) {
		return _iface_->find_for_match (self, query, match);
	}
	return NULL;
}

static gboolean
synapse_action_provider_real_handles_unknown (SynapseActionProvider* self)
{
	gboolean result = FALSE;
	result = FALSE;
	return result;
}

gboolean
synapse_action_provider_handles_unknown (SynapseActionProvider* self)
{
	SynapseActionProviderIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = SYNAPSE_ACTION_PROVIDER_GET_INTERFACE (self);
	if (_iface_->handles_unknown) {
		return _iface_->handles_unknown (self);
	}
	return FALSE;
}

static void
synapse_action_provider_default_init (SynapseActionProviderIface * iface,
                                      gpointer iface_data)
{
	iface->handles_unknown = synapse_action_provider_real_handles_unknown;
}

static GType
synapse_action_provider_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SynapseActionProviderIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_action_provider_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType synapse_action_provider_type_id;
	synapse_action_provider_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseActionProvider", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (synapse_action_provider_type_id, SYNAPSE_TYPE_ACTIVATABLE);
	return synapse_action_provider_type_id;
}

GType
synapse_action_provider_get_type (void)
{
	static volatile gsize synapse_action_provider_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_action_provider_type_id__volatile)) {
		GType synapse_action_provider_type_id;
		synapse_action_provider_type_id = synapse_action_provider_get_type_once ();
		g_once_init_leave (&synapse_action_provider_type_id__volatile, synapse_action_provider_type_id);
	}
	return synapse_action_provider_type_id__volatile;
}

